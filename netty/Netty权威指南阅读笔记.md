Netty权威指南/李林峰著   2014.6版

# 第 1 章 Java的I/O演进之路

## 1.1 I/O基础入门

### 1.1.1 Linux网络I/模型简介
  Linux的内核将所有外部设备都看做一个文件夹操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个file descriptor（fd：文件描述符）。而对一个socket的读写也会有相应的描述符，成为socketfd（socket描述符），描述符就是一个数字，它指向内核中的一个结构体（文件路径，数据区等一些属性）。
  根据UNIX网络编程对I/O模型的分析，UNIX提供了5中I/O模块,分别如下：
  （1）阻塞I/O模型：
  （2）非阻塞I/O模型：
  （3）I/O复用模型：
  （4）信号驱动I/O模型：
  （5）异步I/O：

### 1.1.2 I/O多路复用技术
  epoll与select的原理比较类似，为了克服select的缺点，epoll作了很多重大改进：
  1. 支持一个进行打开的socket描述符（FD）不受限制（仅受限于操作系统的最大文件句柄数）
  2. I/O效率不会随着FD数目的增加而线性下降
  3. 使用mmap加速内核与用户空间的消息传递
  4. epoll的API更加简单

# 第 2 章 NIO入门

## 2.1 传统的BIO编程
## 2.2 伪异步I/O编程

## 2.3 NIO编程

### 2.3.1 NIO类库简介

  1. 缓冲区Buffer
  2. 通道Channel
  Channel是一个通道，可以通过它读取和写入数据，它就像自来水管一样，网络数据通过Channel读取和写入。通道与流的不同之处在于通道是双向的，流只是在一个方向上移动（一个流必须是InputStream或者OutputStrem的子类），而且通道可以用于读、写或者同事用于读写。
  3. 多路复用器Selector
  多路复用器提供选择已经就绪的任务的能力。简单来讲，Selector会不断地轮询注册在其上的Channel，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作.

### 2.3.2 NIO服务端序列图

  源码示例 P29


### 2.3.4 NIO客户端序列图
  P36

使用NIO编程的有点总结：
（1） 客户端发起的连接操作是异步的，可以通过在多路复用器注册OP_CONNECT等待后续结果，不需要像之前的客户端那样被同步阻塞；
（2） SocketChannel的读写操作都是异步的，如果没有可读写的数据它不会同步等待，直接返回，这样的I/O通信线程就可以处理其他的链路，不需要同步等待这个链路可用；
（3） 线程模型的优化：由于JDK的Selector在Linux等主流操作系统上通过epoll实现，它没有连接句柄数的限制（只受限于操作系统的最大句柄数或者对单个进程的句柄限制），这意味着一个Selector线程可以同时处理成千上万个客户端连接，而且性能不会随着客户端的增加而线程下降，因此，它非常适合做高性能、高负载的网络服务器。

## 2.4 AIO编程
  NIO2.0引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。异步通道提供两种方式获取操作结果：
    通过java.util.concurrent.Future类来表示异步操作的结果；
    在执行异步操作的时候引入一个java.nio.channels
  CompletionHandler接口的实现类作为操作完成的回调。

  NIO2.0的异步套接字通道是真正的异步非阻塞I/O，它对应UNIX网络编程中的事件驱动I/O(AIO)，它不需要通过多路复用器（Selector）对注册的通道进行轮询操作即可实现异步读写，从而简化了NIO的编程模型。

## 2.5 4中I/O的对比
 P58

半包消息的问题？？？

# 第 3 章 Netty入门应用

# 第 4 章 TCP粘包/拆包问题的解决之道

## 4.1 TCP粘包/拆包

### 4.1.1 TCP粘包/拆包问题说明
![TCP粘包拆包问题](./nettypic/TCP粘包拆包问题.JPG)\
  假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。
  （1）服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；
  （2）服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；
  （3）服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D1包的剩余内容，被称为TCP拆包；
  （4）服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1,第二次读取到了D1包的剩余内容D1_2和D2包的整包，期间发生了多次的拆包。

### 4.1.2 TCP粘包/拆包产生原因
    问题产生的原因有三个，分别如下：
    （1） 应用程序write写入的字节大小大于套接口发送缓冲区大小；
    （2） 进行MSS大小的TCP分段；
    （3） 以太网帧的payload打于MTU进行IP分片。图解如图所示：\
  ![TCP粘包拆包问题原因](./nettypic/TCP粘包拆包问题原因.JPG)\
  MTU: Maxitum Transmission Unit 最大传输单元 \
  MSS: Maxitum Segment Size 最大分段大小

### 4.1.3 粘包问题的解决策略
  由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下：
  （1） 消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；
  （2） 在包尾增加回车换行符进行分割，例如FTP协议；
  （3） 将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度；
  （4） 更复杂的应用层协议。

## 4.2 
## 4.3 利用LineBasedFrameDecoder解决TCP粘包问题

### 4.3.4 LineBasedFrameDecoder和StringDecoder的原理分析
  LineBasedFrameDecoder的工作原理是它依次遍历ByteBuf中的可读字节，判断看是否有“\n”或者“\r\n”,如果有,就以此位置为结束位置，从可读索引到结束位置区间的字节就组成了一行。它是以换行符为结束标志的解码器，支持携带结束符或者不携带结束符两种解码方式，同时支持配置单行的最大长度。如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常，同时忽略掉之前读取到的异常码流。

  StringDecoder就是将接收到的对象转换成字符串，然后继续调用后面的handler，StringDecoder和LineBasedFrameDecoder的的组合就是按行切换的文本解码器，它被设计用来支持TCP的粘包和拆包。

  Netty提供了多种支持TCP粘包和拆包的解码器，用来满足用户不同的诉求。详细方式在第五章解读

# 第 5 章 分隔符和定长解码器的应用
DelimiterBasedFrameDecoder：可以自动完成对分隔符做结束标记的消息的解码
FixedLengthFrameDecoder:可以自动完成对定长消息的解码


中级篇
Netty 编解码开发指南

# 第 6 章 编解码技术
  当进行远程跨进程服务调用时，需要把被传输的Java对象编码为字节数组或者ByteBuffer对象。而当远程服务读取到ByteBuffer对象或者字节数组时，需要将其解码为发送时的Java对象。这被称为Java对象编解码技术。

## 6.1 Java序列化的缺点

### 6.1.1 无法跨语言
### 6.1.2 序列化后的码流太大
  判断一个编解码框架的优劣时，考虑以下几个因素：
  - 是否支持跨语言，支持的语言种类是否丰富；
  - 编码后的码流大小；
  - 编解码的性能；
  - 类库是否小巧，API适用是否方便；
  - 使用者需要手工开发的工作量和难度。

### 6.1.3 序列化性能太低

## 6.2 业界主流的编解码框架

### 6.2.1 Google的Protobuf介绍

# 第 7 章 Java序列化

# 第 8 章 Google Protobuf编解码
## 8.3 Protobuf的使用注意事项
ProtobufDecoder仅仅负责解码，它不支持读半包。因此，在ProtobufDecoder前面，一定要有能够处理半包的解码器，有三种方式可以选择：
  - 使用Netty提供的ProtobufVarint32FrameDecoder，它可以处理半包消息；
  - 继承Netty提供的通用半包解码器LengthFieldBasedFrameDecoder；
  - 继承ByteToMessageDecoder类，自己处理半包消息。

高级篇
Netty 多协议开发和应用

# 第 10 章 HTTP协议开发应用
todo

# 第 11 章
# 第 12 章
# 第 13 章

# 第 14 章 私有协议栈开发

## 14.2 Netty协议栈功能设计
  Netty协议栈用于内部各模块之间的通信，它基于TCP/IP协议栈，是一个类HTTP协议栈的应用层协议栈，相比于传统的标准协议栈，它更加轻巧、灵活和使用。

### 14.2.1 网络拓扑图
  在分布式组网环境下，每个Netty节点（Netty进程）之间建立长连接，使用Netty协议进行通信。Netty节点并没有服务端和客户端的区分，谁首先发起连接，谁就作为客户端，另一方自然就成为服务端。一个Netty节点既可以作为客户端连接另外的Netty节点，也可以作为Netty服务端被其他Netty节点连接，这完全取决于使用者的业务场景和具体的业务组网。如下图所示：
  ![Netty协议网络拓扑图示意图](./nettypic/Netty协议网络拓扑图示意图.jpg)\

### 14.2.2 协议栈功能描述
Netty协议栈承载了业务内部各模块之间的消息交互和服务调用，它的主要功能如下：
（1） 基于Netty的NIO通信框架，提高高性能的异步通信能力；
（2） 提供消息的编解码框架，可以实现POJO的序列化和反序列化；
（3） 提供基于IP地址的白名单接入认证机制；
（4） 链路的有效性校验机制；
（5） 链路的断连重连机制。

### 14.2.3 通信模型
如下图所示：\
![Netty协议栈通信交互图](./nettypic/Netty协议栈通信交互图.JPG)\

具体步骤：
1. Netty协议栈客户端发送握手请求信息，携带节点ID等有效身份认证信息；
2. Netty协议服务端对握手请求消息进行合法性校验，包括节点ID有效性校验、节点重复登录校验和IP地址合法性校验，校验通过后，返回登录成功的握手应答消息；
3. 链路建立成功之后，客户端发送业务消息；
4. 链路成功之后，服务端发送心跳消息；
5. 链路建立成功之后，客户端发送心跳消息；
6. 链路建立成功之后，服务端发送业务消息；
7. 服务端退出时，服务端关闭连接，客户端感知对方关闭连接后，被动关闭客户端连接。

备注：需要指出的是，Netty协议通信双方链路建立成功之后，双方可以进行**全双工通信**，无论客户端还是服务器端，都可以主动发送请求消息给对方，通信方式可以是TWO WAY或者ONE WAY。双方之间的心跳采用Ping-Pong机制，当链路处于空闲状态时，客户端主动发送Ping消息给服务端，服务端接收到Ping消息后发送应答消息Pong给客户端，如果客户端连续发送N条Ping消息都没有接收到服务端返回的Pong消息，说明链路已经挂死或者对方出入异常状态，客户端主动关闭连接，间隔周期T后发起重连操作，知道重连成功。

### 14.2.4 消息定义---P.255
Netty协议栈消息定义包含两部分:
- 消息头
- 消息体

### 14.2.5 Netty协议支持的字段类型\
![Netty协议支持的字段类型](./nettypic/Netty协议支持的字段类型.jpg)
### 14.2.6 Netty协议的编解码规范---P.257
1. Netty协议的编码；
2. Netty协议的解码

### 14.2.7 链路的建立

### 14.2.8 链路的关闭

### 14.2.9 可靠性设计
1. 心跳机制
2. 重连机制
3. 重复登录保护
4. 消息缓存重发

### 14.2.10 安全性设计

### 14.2.11 可扩展性设计


## 14.3 Netty协议栈开发---重点章节(P.263)

### 14.3.1 数据结构定义
1. 定义Netty协议栈使用的数据结构---NettyMessage类定义
2. 消息头Header类定义

由于心跳消息、握手消息和握手应答消息都可以统一由NettyMessage承载，所以不需要为这几类控制消息做单独的数据结构定义。

### 14.3.2 消息编解码
分别定义NettyMessageDecoder和NettyMessageEncoder用于NettyMessage消息的编解码。

### 14.3.3 握手和安全认证
握手的发起是在**客户端**和服务端TCP链路建立成功通道激活时，握手消息的接入和安全认证在**服务端处理**。

### 14.3.4 心跳检测机制
握手成功之后，由客户端主动发松心跳消息，服务端接收到心跳消息之后，返回心跳应答消息。由于心跳消息的目的是为了检测链路的可用性，因此不需要携带消息体。


源码分析

# 第15章 ByteBuf和相关辅助类
## 15.1 ByteBuf功能说明
当我们进行数据传输的时候，往往需要使用到缓冲区，常用的缓冲区就是JDK NIO类库提供的Java.nio.Buffer。但是ByteBuffer有一些不足：

为了弥补这些不足，Netty提供了自己的ByteBuffer实现---ByteBuf。
## 15.1.1 ByteBuf的工作原理
JDK ByteBuffer由于只有一个位置指针用于处理读写操作，因此每次读写的时候都需要额外调用flip()和clear()等方法，否则功能将出错。

ByteBuf 通过两个位置指针来协助缓冲区的读写操作，读操作使用readerIndex,写操作使用writerIndex。
由于写操作不修改readerIndex指针，读操作不修改writerIndex指针，因此不再需要调整位置指针，这极大地简化了缓冲区的读写操作，避免了由于遗漏或者不熟悉flip()操作导致的功能异常。

## 15.1.2 ByteBuf的功能介绍

1. 顺序读操作（read）
2. 顺序写操作（write）
3. readerIndex和wirterIndex
   Netty提供了两个指针变量用于支持顺序读取和写入操作：readerIndex用于标识读取索引，writerIndex用于标识写入索引。两个位置指针将ByteBuf缓冲区分割成三个区域。如图所示：\
   ![ByteBuf的readerIndex和writerIndex](./nettypic/ByteBuf的readerIndex和writerIndex.jpg)
   调用ByteBuf的read操作时，从readerIndex处开始读取。readereIndex到writerIndex之间的空间为可读的字节缓冲区；从writerIndex到capacity之间为可写的字节缓冲区；0到readerIndex之间是已经读取过的缓冲区，可以调用discardReadBytes操作来宠用这部分空间，以节约内存，防止ByteBuf的动态扩张。

4. Discardable bytes
ByteBuf的discardReadBytes操作效果如下：
操作之前：\
![discardReadBytes操作之前ByteBuf](./nettypic/discardReadBytes操作之前ByteBuf.jpg)

操作之后: \
![discardReadBytes操作之后的ByteBuf](./nettypic/discardReadBytes操作之后的ByteBuf.jpg)

需要指出的是，调用discardReadBytes会发生字节数组的内存复制，所以，频繁调用将会导致性能下降，因此在调用它之前，要确认你确实需要这样做，例如牺牲性能来换取更多的可用内存。

需要指出的是，调用discardReadBytes操作之后的writable bytes内容处理策略跟ByteBuf接口的具体实现有关。
5. Readable bytes和Writable bytes
   可读空间是数据实际存储的区域，以read或者skip开头的任何操作将会从readerIndex开始读取或者跳过指定的数据，操作完成之后readerIndex增加了读取或者跳过的字节数长度。
   可写空间段是尚未被使用可以填充的空闲空间，任何以write开头的操作都会从writerIndex开始向空闲空间写入字节，操作完成之后writerIndex增加了写入的字节数长度。
6. clear操作

并不会清空缓冲区内容本身，例如填充为NULL(0x00).它主要用来操作位置指针。
7. 
## 15.2 ByteBuf源码分析
